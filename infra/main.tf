terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "5.36.0" # Pin to a specific recent 5.x version
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.0"
    }
  }
  # Configure Terraform backend using GCS bucket created by setup script
  # The bucket name pattern is "aipress-tf-state-${GCP_PROJECT_ID}"
  # We need GCP_PROJECT_ID available *before* backend init, so we can't use a var.
  # Instead, we'll rely on the user ensuring the project ID matches the one used in setup.
  # For a robust setup, the bucket name could be passed via init args: -backend-config="bucket=..."
  # Or defined in a separate backend.tfvars file. For PoC, hardcoding pattern is okay.
  backend "gcs" {
    bucket  = "aipress-tf-state-wp-engine-ziggy" # !!! UPDATE MANUALLY if project ID changes from setup script !!!
    prefix  = "infra/poc"
  }
}

provider "google" {
  project = var.gcp_project_id
  region  = var.gcp_region
  # Credentials should be handled via Application Default Credentials (ADC)
  # or by setting the GOOGLE_APPLICATION_CREDENTIALS environment variable
  # pointing to the terraform-key.json file generated by the setup script.
}

# --- Control Plane Cloud Run Service ---

resource "google_cloud_run_v2_service" "control_plane" {
  project  = var.gcp_project_id
  location = var.gcp_region
  name     = "aipress-control-plane" # Name for the control plane service

  template {
    # Use the Terraform SA for this service
    # Ensure this SA has permissions to manage tenant resources (Run, SQL, Storage, Secrets)
    # The 'owner' role granted in poc_gcp_setup.sh covers this for PoC.
    service_account = "${var.tf_sa_name}@${var.gcp_project_id}.iam.gserviceaccount.com"

    scaling {
      min_instance_count = 0 # Allow scale-to-zero for cost savings
      max_instance_count = 2 # Example max instances
    }

    containers {
      # Use the image built by build_and_push_cp_image.sh
      image = var.control_plane_docker_image_url
      ports { container_port = 8000 } # Port defined in control-plane/Dockerfile

      # Pass necessary environment variables to the control plane container
      env {
        name  = "GCP_PROJECT_ID"
        value = var.gcp_project_id
      }
      env {
        name  = "GCP_REGION"
        value = var.gcp_region
      }
      env {
        name  = "SHARED_SQL_INSTANCE_NAME"
        value = var.shared_sql_instance_name
      }
      env {
        name  = "WP_RUNTIME_SA_NAME"
        value = var.wp_runtime_sa_name
      }
      env {
        name  = "WP_DOCKER_IMAGE_URL"
        value = var.wp_docker_image_url
      }
      env {
        # Also pass the control plane image URL itself as an env var
        # so the app can pass it back to terraform apply
        name  = "CONTROL_PLANE_DOCKER_IMAGE_URL"
        value = var.control_plane_docker_image_url
      }
      # TF_MAIN_PATH is handled inside the container relative to /app
      # GOOGLE_APPLICATION_CREDENTIALS is not needed when using service account identity

      # Optional: Add resource limits
      # resources {
      #   limits = {
      #     cpu    = "1000m"
      #     memory = "512Mi"
      #   }
      # }
    }

    # Optional: Configure VPC Access Connector if needed (e.g., for private SQL)
    # vpc_access {
    #   connector = "your-vpc-connector-id"
    #   egress    = "all-traffic"
    # }
  }

  # Public access is configured via google_cloud_run_service_iam_binding below

  # Ensure the necessary APIs are enabled before creating the service
  depends_on = [google_project_service.apis] # Assuming the API enablement resource exists and is named 'apis'
}

# Allow unauthenticated access to the Control Plane service (for PoC)
# WARNING: Remove this for production and use authenticated access (e.g., IAP)
resource "google_cloud_run_service_iam_binding" "control_plane_public_access" {
  project  = google_cloud_run_v2_service.control_plane.project
  location = google_cloud_run_v2_service.control_plane.location
  service  = google_cloud_run_v2_service.control_plane.name
  role     = "roles/run.invoker"
  members = [
    "allUsers",
  ]
}

# --- API Enablement Resource ---
# Enable necessary APIs for the project (needed by Control Plane and Tenant Modules)
resource "google_project_service" "apis" {
  for_each = toset(var.enable_apis)
  project  = var.gcp_project_id
  service  = each.key
  # Disable dependent services potentially tears down things unexpectedly
  # We enable them explicitly in poc_gcp_setup.sh or here
  disable_dependent_services = false
}

# --- Tenant Module Invocation Placeholder ---
# Example invocation for a single tenant during PoC development
# The Control Plane will override tenant_id and wp_runtime_sa_email via -var flags
# based on the API request.
module "tenant_wordpress_instance" { # Renamed for clarity
  source = "./modules/tenant_wordpress"

  # These variables will be overridden by the control plane's -var flags
  tenant_id                = var.tenant_id           # Use variable
  wp_runtime_sa_email      = var.wp_runtime_sa_email # Use variable

  # These are consistent across tenants for this PoC
  gcp_project_id           = var.gcp_project_id
  gcp_region               = var.gcp_region
  shared_sql_instance_name = var.shared_sql_instance_name
  wp_docker_image_url      = var.wp_docker_image_url # Passed via -var to root

  # sql_password_secret_id - Module generates this
}
